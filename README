Wednesday May 27, 2015
Jesse Maurais

Lux is an emitting C++ glue for Lua. By 'emitting' I mean that it exploits the
C++ ability to generate functions at compile time. This happens whenever a 
templated function recieves a new argument type. Using this feature, as well as
a few C++11 additions, Lux manages to greatly simplify the task of exporting C
functions, structures, arrays, and C++ classes to the Lua language. It is so
simple that the user need only learn one function to perform the most basic
task of exporting a C function.

	lux_register(state, AnyFunction);

Where state is a pointer to a valid lua_State. This function is actually a
macro for the following

	#define lux_register(L, fun) lua_register(L, #fun, lux_cast(fun))

The latter being useful if you want Lua to refer to the function by another
name. The lux_cast macro returns a lua_CFunction which is a wrapper for any
arbitrary C function or C++ class function. Using C++11 or newer you have
access to lambda (anonymous) functions which can elaborate further to

	#define lux_wrap(fun) [](lua_State *L) { return lux_thunk(L, &fun); }
	#define lux_cast(fun) static_cast<lua_CFunction>(lux_wrap(fun))

The above lux_thunk is a dispatching routine responsible for converting the Lua
stack values to the appropriate arguments for fun and pushing its return value,
if any. This way lux_cast(fun) has the type lua_CFunction and can be used any
place in the Lua CAPI that asks for it. For example, you can pass it as the
CFunction in a luaL_Reg entry before a call to luaL_setfuncs. See test5.cpp
for an example doing this on a subset of the SDL2 API. 

Lux was designed to be minimalist and non intrusive. This means that you should
not have to modify any of your existing C/C++ code in order to give it to the
state machine. You do not need to write any "wrapper" functions to manipulate
the stack for C function calls (a lengthy process). Nor do you need to run an
external program that will parse your sources (an error prone process) to
generate extra sources files for your build (a cumbersome process). Everything
normally done by the user to export their native code is instead done by the
compiler itself when the C++ source code is first processed.

What this means is that you don't have to maintain or manually edit the code
for interface changes. The C++ compiler already does this. The pragmatic aspect
of this is that you can implement changes to your scripting interface without
too much unnecessary hassel.

You're welcome.

